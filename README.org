#+title: Živa

Live coding with SuperCollider patterns made easy (hopefully).

This is a set of tools and syntax sugar for easy live coding with SuperCollider patterns.

A general purpose framework for smoothly playing samples and synths.

/WARNING: This software is still under heavy development and might considerably change in future versions./
* Requirements
** All OS

    - SuperCollider: https://github.com/supercollider/supercollider - tested with v3.12.2
    - sc3-plugins: https://github.com/supercollider/sc3-plugins/
    - optional, but recommended (for the Dirt-Samples library): SuperDirt quark: https://github.com/musikinformatik/SuperDirt

** Windows
  Windows users also need to install git: https://gitforwindows.org/

* Installation from SuperCollider
#+begin_src sclang
Quarks.install("https://github.com/loopier/ziva");
#+end_src

if you have already installed it before, and simply want to update:

#+begin_src sclang
Quarks.update("ziva");
#+end_src

* License
(C) 2022- Roger Pibernat

Živa is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this library.  If not, see <http://www.gnu.org/licenses/>.


* Živa for beginners

This guide is intended for people who have never used SuperCollider before. If you already know SuperCollider you might want to check [[ZivaForSuperColliderUsers.org][Ziva for SuperCollider Users]] or [[QuickReference.org][Quick Reference]] instead.

** SuperCollider essentials

To evaluate code in SuperCollider, put the cursor in the line you want to evaluate (or select all the code needed) and press ~CTRL/CMD-RETURN~.

To stop all sounds, perss ~CTRL/CMD-.(period)~. *REMEMBER THIS!!*

** Setup
*** Booting the server
First of all we need to boot SuperCollider's server (sound engine).
#+begin_src sclang
Ziva.boot;
#+end_src

You can set some sever options with arguments, e.g. to set more audio channels:

#+begin_src sclang
Ziva.boot(inputChannels:2, outputChannels:2);
#+end_src

or increase memory

#+begin_src sclang
Ziva.boot(numBuffers:16, memSize:32, maxNodes:32);`
#+end_src

*** Samples
In Živa two types of sounds can be played: samples and synths. The path to the samples directory must be set. Some default synths are loaded automatically.

The path to the samples directory must be holding subdirectories, which themselves store the audio files.

Each subdirectory name will become the sample name accessible from Ži va, and each sample within that directory will be accessed with the ~n~ function.  More on this later.

#+begin_src sclang
Ziva.loadSamples("path/to/samples/parent/directory");
#+end_src

For example, you can load the samples that come with this quark:

#+begin_src sclang
Ziva.loadSamples(Platform.userAppSupportDir++"/downloaded-quarks/ziva/samples");
#+end_src

Several sample lists can be added from different folders, with consecutive calls to this function; beware that if there are two subfolders with the same name only the last one will prevail.

To list all loaded samples, evaluate this function and check the post window (the number between ~()~ is the number of audio files in that subdirectory):

#+begin_src sclang
Ziva.sounds;
#+end_src

*** Synths

To list currently available synths use:

#+begin_src sclang
Ziva.synths;
#+end_src

*** Tempo

For now, to set the BPM we need to use regular SuperCollider:

#+begin_src sclang
TempoClock.default.tempo = 120/60; // 120 bpm
#+end_src

This value can be changed at any time and will affect all sounds.

** Playing Sounds

Živa follows a model that mimmics music bands: there are musicians in a band that play instruments following scoresheets.

To start we must have a musician, which is just a SuperCollider variable. For example:
#+begin_src sclang
~lola
#+end_src

This musician needs to play an instrument, it can be either a synth or a sample:
#+begin_src sclang
  ~lola = Psynth(\acid);
  // or
  ~delia = Psample(\delia);
#+end_src

The name preceded by ~\~ is the name of the synth or sample listed by ~Ziva.synths~ or ~Ziva.sounds~.

In order to play, the musician needs to be in a band, which is just a list (actually a SuperCollider ~Array~) of musicians:
#+begin_src sclang
  (
  [
      ~lola,
  ].ziva;
  )
#+end_src

A few hints about this code:
1. The starting and ending ~()~ let us evaluate all the code within these parenthesis without having to select it.
2. ~.ziva~ is a function that will make the band start playing at once on the beginning of the next beat.

If you evaluate this code you should hear an acid bass playing middle C.

To stop the sound there are 3 options:
- press ~CTRL/CMD-.~
- evaluate ~Ziva.stop;~
- or empty (and evaluate) the band:
  #+begin_src sclang
    (
    [
        // ~lola,
        nil
    ].ziva
    )
  #+end_src

** Changing the Sound
The sound can be changed by setting its parameters with function calls. Some of these parameters are common to both samples and synths. Others are specific to either samples or synths. And a few are specific to one type of synth only. Anyhow, they all use functions that can be chained. In the following examples I'm using one-liners because I'm showing one parameter at a time and wanted to keep the file short, but while live coding I find it more convenient to use the multi-line syntax shown above:

#+begin_src sclang
(
[
	~lola,
].ziva;
)
#+end_src

All parameters (function names) try to use conventional music notation veocabulary or intuitive names.

Let's start with parameters that are common to both samples and synths:
** Parameters for Samples and Synths
*** duration

Duration sets how many times per beat a sound is played. If it's not set, it defaults to 1 hit per beat; it will sound once every beat.

If it's set to ~fast~, it will play twice per beat. Try evaluating this line:

#+begin_src sclang
[~lola.fast].ziva;
#+end_src

Other options are: ~faster~, ~fastest~, ~slow~, ~slower~, ~slowest~

For custom duration (in beats) use ~.dur()~:

#+begin_src sclang
[~lola.dur(1/3)].ziva;
#+end_src

*** volume

To play louder add ~f~ (for /forte/; to play softer use ~p~ (for /piano/):

#+begin_src sclang
[~lola.f].ziva;
[~lola.p].ziva;
#+end_src

Other options are: ~ff~, ~fff~, ~ffff~, ~pp~, ~ppp~

Custom loudness can be set with ~.amp()~. *BE CAREFUL!! NEVER GO ABOVE 1.0!!!*

#+begin_src sclang
[~lola.amp(0.2)].ziva;
#+end_src


*** legato (sustain)

Set how long a note sounds. To play staccato notes use ~stacc~:

#+begin_src sclang
    [~lola.stacc].ziva;
#+end_src

Other opstions are: ~pizz~ (pizzicato), ~stass~ (stacatissimo), ~stacc~, ~tenuto~, ~legato~, ~pedal~

For custom length use ~.legato()~:

#+begin_src sclang
   [~lola.legato(1.2)].ziva,
#+end_src


*** panning
Distributes sound along stereo field.

left

#+begin_src sclang
[~lola.left].ziva;
// or
[~lola.pan(-1)].ziva;
#+end_src

right

#+begin_src sclang
[~lola.right].ziva;
// or
[~lola.pan(1)].ziva;
#+end_src

center (default -- doesn't need to be set)

#+begin_src sclang
[~lola.pan(0)].ziva;
#+end_src

alternate between left and right

#+begin_src sclang
[~lola.pingpong].ziva;
#+end_src

random panning on every hit:

#+begin_src sclang
[~lola.randpan].ziva;
#+end_src

custom

#+begin_src sclang
[~lola.pan(-0.5)].ziva; // -1 far left, 1 far right
#+end_src


*** rhythm

There are a few ways to set the rhythm in Živa.

The most basic ones is setting rests in other parameter sequences. This is explained later, after we've talked about sequencing. Rhythm sequences can also be set as a separate parameter (more on this later, too).

For now we'll just talk about the ~.bj()~ function, which stands for Bjorklund, an algorithm that creates Euclidean rhythms.

**** euclidean rhythms
Euclidean rhythms try to distribute, as evenly as possible, a number of hits across a number fo beats.

If we want to distribute 3 hits along 8 beats as evenly as possible we will use ~.bj(3,8)~ (first argument is number of hits, second number of beats):

#+begin_src sclang
[~lola.faster.bj(3,8)].ziva;
#+end_src

By evaluating this, a rhythm of 3 hits should be playing.

This rhythm can be delayed by any number of beats (third argument).

The next exmaple plays the same rhythm as above but delayed by one beat:

#+begin_src sclang
  [
      ~lola.faster.bj(5,8), // play the rhtyhm on the whole instrument
      ~lola.faster.deg([0,2,4].bj(3,8).pseq), // will arpegiate with a bj(3,8) rhythm

  ].ziva;
#+end_src

This function works both on patterns (instruments), and arrays.

#+begin_src sclang
  [
      ~lola.faster.bj(5,8,1),
      ~lola.deg()
  ].ziva;
#+end_src

**** creative rhythms
A quick way to get uneven rhythms is to create an euclidean rhythm then shuffle it:

#+begin_src sclang
[~lola.faster.bj(5,8,scramble:true)].ziva;
#+end_src

The code above will create 5 random hits over 8 beats. Should change on every evaluation.

Streams of hits can also be played. The following example plays a pattern of 5 silent beats followed by 3 hits:

#+begin_src sclang
[~lola.faster.bj(3,8,sort:true)].ziva;
#+end_src

These patterns can also be reversed:

#+begin_src sclang
[~lola.faster.bj(3,8,reverse:true)].ziva;
#+end_src

**** custom rhythms
To create custom rhythms there's the ~r~ variable, which is a rest.
It can be added to any pattern (more on patterns later) of any parameter (except ~dur~) in order to add rests.

#+begin_src sclang
[~lola.deg([0,r,4,r].pseq)].ziva;
#+end_src

It is useful having an independent parameter/function for rhythms.  It can be named anything. I usually use ~.r()~

#+begin_src sclang
[~lola.deg((..7).prand).r([1,r,r,1,r,r,1,r,1,r,1,r].pseq)].ziva;
#+end_src

**** preset rhythms

Živa provides some default rhtyhms.

To list them:

#+begin_src sclang
Ziva.rhythms;
#+end_src

To see a rhythm pattern:

#+begin_src sclang
Ziva.rhythm(\clave); // check the post window
#+end_src

Rhythms are applied to lists. Each element in the list will consecutively be added to the next hit in the rhythm:

#+begin_src sclang
[0,2,4].clave; // -> [ r, r, 0, r, 2, r, r, r, 4, r, r, 0, r, r, 2, r ]
#+end_src

See the post window.

Here's an example with audio:

#+begin_src sclang
[~lola.faster.deg([0,4].clave.pseq)].ziva;
#+end_src

This can by applied to any sound argument.

#+begin_src sclang
~lola = Psynth(\acid);
(
[
    ~lola.faster.cutoff([200,2000].clave.pseq),
].ziva;
)
#+end_src

Some rhythms are divided into two bars that can be played in reverse.

#+begin_src sclang
Ziva.rhythm(\clave);
#+end_src

this shows two nested arrays, each one being a bar. The /clave/ rhythm can be either 2/3:

#+begin_src sclang
[0,2,4].clave;
#+end_src

or 3/2:

#+begin_src sclang
[0,2,4].clave(reverse:1);
#+end_src

** Parameters for Synths
*** note - degree
When playing a synth, notes can be changed with different parameters:

- ~.deg()~ or ~.degree()~ plays notes on a scale, ~0~ being the root.
- ~.note()~ plays chromatically from the root ~0~.
- ~.midinote()~ is set with MIDI note values, ~60~ is middle C.
- ~.freq()~ can be used to set frequency in Hz.

Here we will only look at ~deg~.

#+begin_src sclang
[~lola.deg(2)].ziva;
#+end_src

The code above plays the 3rd note from the scale (degree).

To play a chord, use an array of notes. Following is a major triad:

#+begin_src sclang
[~lola.deg([0,2,4])].ziva;
#+end_src

The degrees that are played depend on the scale that is set (~\major~ by default).

To list all available scale names in the post window use:

#+begin_src sclang
Scale.directory;
#+end_src

A minor chord can be played by changing to a minor scale:
#+begin_src sclang
[~lola.deg([0,2,4]).scale(\minor)].ziva;
#+end_src

Degrees can also be altered with ~s~ to sharpen and ~b~ to flatten.

Play a minor chord over a major scale:

#+begin_src sclang
[~lola.deg([0,2b,4])].ziva;
#+end_src

Play a major chord over a minor scale:

#+begin_src sclang
[~lola.deg([0,2s,4].scale(\minor))].ziva;
#+end_src

*** octave
By default, SuperCollider patterns play on the 5th octave. To play one octave lower:

#+begin_src sclang
[~lola.oct(4)].ziva;
#+end_src

** Synth Parameters
Parameters specific to a synth can also be modified. To see what parameters are avaiable for a given synth use:

#+begin_src sclang
Ziva.controls(\acid); // \acid is the synth name
#+end_src

See the post window. It displays all the parameter names that can be changed with function calls, and their current values.

Controlling these parameters is done as with any other parameter:

#+begin_src sclang
[~lola.cutoff(8000)].ziva;
[~lola.cutoff(200)].ziva;
#+end_src

** Sample Parameters
To list the available samples

#+begin_src sclang
Ziva.sounds;
#+end_src

See the post window.
The number displayed between ~()~ is the number of samples with that name.

The following code sets a sample player to a variable and plays it.

#+begin_src sclang
~delia = Psample(\delia);
[~delia].ziva;
#+end_src

*** Changing sample name
The sample (group) can be changed on the fly with ~.sound(\samplename)~.

#+begin_src sclang
[~delia.sound(\tibetan)].ziva;
#+end_src

*** Changing sample index
Each sample name usually has more than one sample audio file available. To change the sample file number use ~.n(number)~:

#+begin_src sclang
[~delia.n(1)].ziva;
#+end_src

if the number is greater than the number of samples in that sample folder it will wrapped around.

*** Speed
Samples can be played at different speeds:
#+begin_src sclang
[~delia.speed(0.5)].ziva;
#+end_src

The code above plays the sample at half speed.

*** Random speeds

Random speed sequences can be created from a list of speeds. First argument is the number of steps in the sequence, the second is a list of speeds to choose from.

#+begin_src sclang
[~delia.randspeeds(4, [1,-1,2,-1])].ziva;
#+end_src

*** Tape effect
Old cassette tape effect (gets crazy pretty fast):

#+begin_src sclang
[~delia.slow.tape(0.9)].ziva;
#+end_src

*** Starting point

The sample doesn't need to start playing from the beginning. To change the starting point in the sample use ~.start()~ (~0.0~ for beginning, ~1.0~ for end):

#+begin_src sclang
[~delia.start(0.5)].ziva; // start in the midpoint
#+end_src

*** Chop and scramble

The samples can be chopped and recomposed from its pieces with ~.chop()~.
The number of chunks to be sliced is set by the second argument. Then a new sequence is created from those chunks. The size of the sequence is given by the first argument.

This example sequences 4 pieces chosen from a list of 8 chunks.

#+begin_src sclang
[~delia.chop(4, 8)].ziva;
#+end_src

** MIDI
MIDI instruments can also be played, but MIDI needs to be initialized first.

To initialize the client:

#+begin_src sclang
MIDIClient.init;
#+end_src

Then connect the first SuperCollider MIDI output ~MIDIOut(0)~ to your MIDI device with your MIDI user iterface (this is different for each operative system).

Then create a musician that plays that instrument.

#+begin_src sclang
~wendy = Pmidi(MIDIOut(0));
// or
~wendy = Pmidi(MIDIOut(0), 1); // to send MIDI to channel 2
#+end_src

~MIDIOut(0)~ syntax may be different for OSX and Windows -- the example above is for Linux.

MIDI channel is optional, default is 0 -- /WARNING: in SC MIDI channels range 0-15, while the standard is 1-16./

#+begin_src sclang
[ ~wendy.oct(4).deg([0,2,4].pseq) ].ziva;
#+end_src


** Patterns

Parameters can be set to change automatically with *PATTERNS*.
There is a HUGE amount of patterns in SuperCollider, but a lot can be
done with very few. Here we'll present only some of them.

Patterns can modulate any parameter, they can be combined and nested to create really complex sequences.

*** basic sequence pattern

~.pseq(repeats)~ is used to repeat a sequence of values for a number of times. If no ~repeats~ are specified, it loops for ever.

#+begin_src sclang
[~lola.deg([0,2,4].pseq)].ziva;
#+end_src

The code above plays an arpeggio of root-third-fifth indefinitely.

As stated above, ~r~ (rests) can be inserted in sequences to create rhythms.

#+begin_src sclang
[~lola.deg([0,r,4].pseq)].ziva;
#+end_src

*** random pattern
~.prand(repeats)~ picks a random value from the list on each event (beat):

#+begin_src sclang
[~lola.deg([0,1,2,3,4,r].prand)].ziva;
#+end_src

*** nesting patterns
Patterns can be used inside other patterns. There's no limit on the levels of nesting:

#+begin_src sclang
[~lola.faster.deg([0,1,2, [7,8,9].pseq(2)].prand)].ziva;
#+end_src


*** other patterns
Other interesting patterns are ~Place~, ~Pshuf~, ~Pbrown~, ~Pwhite~, ~Pstutter~, ...
See [[http://doc.sccode.org/Tutorials/A-Practical-Guide/PG_02_Basic_Vocabulary.html][A-Practical-Guide/PG_02_Basic_Vocabulary]] in SCHelp.

*NOTE:* Živa pattern syntax differs from regular SuperCollider pattern syntax, but both syntaxes can be used. To see what patterns are available in Živa syntax, see [[./Classes/sequenceablecollection.sc]]

Following is an example using both regular SuperCollider pattern syntax and Živa pattern syntax.

#+begin_src sclang
(
[
  ~lola.faster.legato(Pwhite(0.1,1.2)).bj(4,7).cutoff(8000),
  ~lola.oct([3,4].pseq),
].ziva;
)
#+end_src



** Harmony
A harmonic sequence with it's own rhtyhm can be set with `Ziva.harmony(degrees, durations)`;

`degrees` is a pattern that sets the root notes of the chords of the harmonic progression.

`durations` is a pattern that sets the harmonic rhythm (units are of 1 beat).

For example:

#+begin_src sclang
  // to set a chord progression of
  // root note for 3 beats
  // 2nd degree for 1 beat
  // 6th degree one octave lower for 2 beats
  // 7th degree one octave lower for 2 beats
  ~harmony = Ziva.harmony([0,1,-2,-1].pseq, [3,1,2,2].pseq);
#+end_src

** Modulation
Another way to modulate parameters is with LFOs (Low Frequency Oscillator).

This example creates a sine wave oscillator and uses it to modulate the
cutoff frequency of our ~\acid~ synth.

#+begin_src sclang
~sine1 = Ziva.lfo(1, wave:\sine, freq:0.6, min:200, max:8000  );
[~lola.legato.cutoff(~sine1)].ziva;
#+end_src

You can create as many LFOs as you want, but the first parameter must be
different for each LFO or it will be overwitten (can be a number or a [[http://doc.sccode.org/Classes/Symbol.html][symbol]]).

Available LFO wave shapes are: ~\sine~, ~\saw~, ~\pulse~, ~\tri~, ~\noise0~, ~\noise1~, ~\noise2~

** Effects

Sound effects (reverb, delay, chorus, ...) can be added to the signal chain. To list available effects use:

#+begin_src
Ziva.fx; // see the post window
Ziva.boot; // this might have to be called -- it's a bug, will be fixed
#+end_src

Important things to consider regarding effects:

- Effects are applied to tracks, not sounds.
- Any number of tracks can be added.
- Any number of effects can be applied to each track (including none, or ~nil~).
- Order of the effects in each track matters.

To setup effects for tracks:

#+begin_src
Ziva.track(0, \lowpass, \reverbL);
Ziva.track(1, \delay);
#+end_src

The first argument is the track name (numbers can also be used). The rest are the effects to be added, *in the order that they will be applied*.

Then connect each sound to the desired track using ~>>~:

#+begin_src
(
[
	~lola.oct([3,4]).cutoff(9000) >> 0,
	~lola.pizz.slow >> 1,
].ziva;
)
Ziva.track(0); // remove the fx from track 0
#+end_src

** Drums

/WARNING: This is experimental/

Drums can be just synths or samples, but there's a special class for the
free AVL plugin that can be downloaded at http://www.bandshed.net/avldrumkits/

This is just a wrapper for AVL's MIDI mapping, it might work with other MIDI drum sets, I haven't tried it.

Create a drummer that sends MIDI (remember to connect it in the MIDI routing app):

#+begin_src sclang
~bonzo = Pavldrums(MIDIOut(0));
#+end_src

With this, you can play drums with strings of characters, where
specific characters are mapped to certain MIDI notes corresponding
to specific drum kits in the AVL plugin.

Spaces are rests.

#+begin_src sclang
[ ~bonzo.drums("b h s h b h s o ").faster ].ziva;
#+end_src

To see the mappings:

#+begin_src sclang
Ziva.drums;
#+end_src

