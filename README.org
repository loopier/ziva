#+title: Živa

Live coding with SuperCollider patterns made easy (hopefully).

Set of tools and syntax sugar for easy live coding with SuperCollider patterns.
A general purpose framework for smoothly playing samples and synths.

* Requirements

    - SuperCollider: https://github.com/supercollider/supercollider - tested with v3.12.2
    - optional, but recommended (many effect UGens need it): sc3-plugins: https://github.com/supercollider/sc3-plugins/
    - optional, but recommended (for the Dirt-Samples library): SuperDirt quark: https://github.com/musikinformatik/SuperDirt
    - optional: DrumPattern quark: https://github.com/loopier/drumpattern

* Installation from SuperCollider
#+begin_src sclang
Quarks.install("https://github.com/loopier/ziva");
#+end_src

if you have already installed it before, and simply want to update:

#+begin_src sclang
Quarks.update("ziva");
#+end_src

* License
(C) 2022- Roger Pibernat

Živa is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this library.  If not, see <http://www.gnu.org/licenses/>.


* Živa for beginners

This guide is intended for people who have never used SuperCollider before. If you already know SuperCollider you might want to check the [[*Živa quick reference][Živa quick reference]], or [[*Živa tips and tricks][Živa tips and tricks]] instead.

To evaluate code in SuperCollider, put the cursor in the line you want to evaluate (or select all the code needed) and press ~CTRL/CMD-RETURN~.

To stop all sounds, perss ~CTRL/CMD-.(period)~. *REMEMBER THIS!!*

** Setup
*** Booting the server
First of all we need to boot SuperCollider's server (sound engine).
#+begin_src sclang
Ziva.boot;
#+end_src

You can set some sever options with arguments, e.g. to set more audio channels:

#+begin_src sclang
Ziva.boot(inputChannels:2, outputChannels:2);
#+end_src

or increase memory

#+begin_src sclang
Ziva.boot(numBuffers:16, memSize:32, maxNodes:32);`
#+end_src

*** Samples
In Živa two types of sounds can be played: samples and synths. The path to the samples directory must be set. Some default synths are loaded automatically.

The path to the samples directory must be holding subdirectories, which themselves store the audio files.

Each subdirectory name will become the sample name accessible from Živa, and each sample within that directory will be accessed with the `n` function.  More on this later.

#+begin_src sclang
Ziva.loadSamples("path/to/samples/parent/directory");
#+end_src

For example, you can load the samples that come with this quark:

#+begin_src sclang
Ziva.loadSamples(Platform.userAppSupportDir++"/downloaded-quarks/ziva/samples");
#+end_src

Several sample lists can be added from different folders, with consecutive calls to this function; beware that if there are two subfolders with the same name only the last one will prevail.

To list all loaded samples, evaluate this function and check the post window (the number between ~()~ is the number of audio files in that subdirectory):

#+begin_src sclang
Ziva.sounds;
#+end_src

*** Synths

To list currently available synths use:

#+begin_src sclang
Ziva.synths;
#+end_src



** Playing Sounds

Živa follows a model that mimmics music bands. There are musicians in a band that play instruments following scoresheets.

To start we must have a musician, which just a variable. For example:
#+begin_src sclang
~lola
#+end_src

This musician needs to play an instrument, it can be either a synth or a sample:
#+begin_src sclang
  ~lola = Psynth(\acid);
  // or
  ~lola = Psound(\delia);
#+end_src

The name preceded by ~\~ is the name of the synth or sample listed by ~Ziva.synths~ or ~Ziva.sounds~.

In order to play, the musician needs to be in a band, which is just a list (actually a SuperCollider ~Array~) of musicians:
#+begin_src sclang
  (
  [
      ~lola,
  ].ziva;
  )
#+end_src

This code will help us understand a few things:
1. The starting and ending ~()~ let us evaluate all the code within these parenthesis without having to select it.
2. ~.ziva~ is a function that will make the band start playing at once on the beginning of the next beat.

If you evaluate this code you should hear either Delia Derbyshire saying something, or an acid bass playing middel C, depending on what you evaluated last when setting up the instrument for ~\~lola~.

To stop the sound there are 3 options:
- press ~CTRL/CMD-.~.
- evaluate ~Ziva.stop;~
- or empty the band:
  #+begin_src sclang
    (
    [
        // ~lola,
        nil
    ].ziva
    )
  #+end_src

** Changing the Sound
The sound can be changed in many different ways. Some of these are common to both samples and synths. Others are specific to samples or synths. And a few are specific to one type of synth only. Anyhow, they all use functions that can be chained. in the following examples I'm using one-liners because I'm showing one parameter at a time and wanted to keep the file short, but while live coding I find it more convenient to use the multi-line syntax shown above:

#+begin_src sclang
(
[
	~lola,
].ziva;
)
#+end_src

Let's start with parameters that are common to both samples and synths:

*** tempo

#+begin_src sclang
[~lola.fast].ziva;
#+end_src

Other options are: ~faster~, ~fastest~, ~slow~, ~slower~, ~slowest~

For custom duration (in beats):

#+begin_src sclang
[~lola.dur(1.3)].ziva;
#+end_src

*** volume

To play louder add ~f~ (for /forte/):

#+begin_src sclang
[~lola.f].ziva;
#+end_src

Other options are: ~ff~, ~fff~, ~ffff~, ~p~, ~pp~, ~ppp~

Custom loudness can be set with ~amp~. *BE CAREFUL!! NEVER GO ABOVE 1.0!!!*

#+begin_src sclang
[~lola.amp(0.2)].ziva;
#+end_src


*** legato (sustain)

#+begin_src sclang
    [~lola.stacc].ziva;
#+end_src

Other opstions are: ~pizz~, ~stass~, ~stacc~, ~tenuto~, ~legato~, ~pedal~

For custom length use ~legato~:

#+begin_src sclang
   [~lola.legato(1.2)].ziva,
#+end_src


*** panning
Distribution along stereo field.

left

#+begin_src sclang
[~lola.pan(-1)].ziva;
#+end_src

right

#+begin_src sclang
[~lola.fast.pan(1)].ziva;
#+end_src

center (default)

#+begin_src sclang
[~lola.slow.pan(0)].ziva;
#+end_src

alternate between left and right

#+begin_src sclang
[~lola.pingpong].ziva;
#+end_src

custom

#+begin_src sclang
[~lola.pan(-0.5)].ziva;
#+end_src


*** TODO rhythm

euclidean rhythms
creates a rhythm. It distributes as evenly as possible a number
of hits (first argument) across a number fo beats (second argument).

#+begin_src sclang
[~lola.faster.bj(3,8)].ziva;

will create 3 hits over 8 beats

#+begin_src sclang
[~lola.faster.bj(5,8,1)].ziva;#+end_src

will create 5 hits over 8 beats delayed

#+begin_src sclang
							#+end_src

by 1 beat

#+begin_src sclang
[~lola.faster.bj(5,8,scramble:true)].ziva;#+end_src

will create 5 random hits over

#+begin_src sclang
										#+end_src

8 beats

#+begin_src sclang
[~lola.faster.bj(3,8,sort:true)].ziva;#+end_src

will create 5 silent beats then 3 hits

#+begin_src sclang
[~lola.faster.bj(3,8,reverse:true)].ziva;#+end_src

reverse order from first example

#+begin_src sclang

#+end_src

to create custom rhythms there's the `r` variable, which is a rest.
it can be added to any pattern (more on patterns later) of any parameter (except
`dur`) in order to add rests.

#+begin_src sclang
[~lola.deg([0,r,4,r].pseq)].ziva;
#+end_src

it is useful having an independent parameter for rhythms.  It can be named
anything. I usually use .r()

#+begin_src sclang
[~lola.deg((..7).prand).r([1,r,r,1,r,r,1,r,1,r,1,r].pseq)].ziva;

#+end_src

there are also some default rhtyhms
to list them

#+begin_src sclang
Ziva.rhythms;
#+end_src

to see a rhythm pattern

#+begin_src sclang
Ziva.rhythm(\clave);
#+end_src

rhtyhms can be applied to pattern sequences (arrays)
when a rhythm is invoked on a list, the elements will
replace the hits (1s) in the pattern keeping the rests.
to see how it works

#+begin_src sclang
[0,2,4].clave;

see the post window
audio example

#+begin_src sclang
[~lola.faster.deg([0,4].clave.pseq)].ziva;
#+end_src

this can by applied to any sound argument

#+begin_src sclang

#+end_src

some rhythms are divided into two bars that can be played in reversed order
e.g.: clave can be 2/3

#+begin_src sclang
Ziva.rhythm(\clave);

this shows two nested arrays, each one being a bar

#+begin_src sclang
[0,2,4].clave;
#+end_src

or 3/2

#+begin_src sclang
[0,2,4].clave(reverse:1);

#+end_src

SYNTHS
when playing a synth, notes can be changed

#+begin_src sclang
[~lola.deg(2)].ziva;#+end_src

plays the 3rd note from the scale

#+begin_src sclang
[~lola.deg([0,2,4])].ziva;#+end_src

plays a major chord

#+begin_src sclang
[~lola.deg([0,2,4]).scale(\minor)].ziva;#+end_src

plays minor chord

#+begin_src sclang
[~lola.oct(4)].ziva;#+end_src

one octave lower (default is 5)
degree notes can be alterated with sharps (s) and flats (b)

#+begin_src sclang
[~lola.deg(0,2b,4)].ziva;

plays a minor chord although the scale is major

#+begin_src sclang
[~lola.deg(0,2s,4).scale(\minor)].ziva;

plays a major chord although the scale is minor

#+begin_src sclang

#+end_src

to list all available scale names in the post window

#+begin_src sclang
Scale.directory;

#+end_src

synth parameters can also be modified
to see what parameters are avaiable for a synth

#+begin_src sclang
Ziva.controls(\acid);

see the post window

#+begin_src sclang
[~lola.cutoff(8000)].ziva;
[~lola.cutoff(200)].ziva;

#+end_src

SAMPLES
to list the available samples

#+begin_src sclang
Ziva.sounds;

see the post window.
The number displayed between () is the number of samples with that name

#+begin_src sclang
~delia = Psample(\delia);
[~delia].ziva;
#+end_src

change sample name for a musician in the band

#+begin_src sclang
[~delia.sound(\tibetan)].ziva;
#+end_src

change sample number (if greater than the number of samples in
that sample folder it will wrapped around)

#+begin_src sclang
[~delia.n(1)].ziva;
#+end_src

change the playing speed
#+begin_src sclang
[~delia.speed(0.5)].ziva;

half speed
sequence a list of speeds. First argument is the number of steps in
the sequence, the second is a list of speeds to choose from.

#+begin_src sclang
[~delia.randspeeds(4, [1,-1,2,-1])].ziva;
#+end_src

old cassette tape effect

#+begin_src sclang
[~delia.slow.tape(0.9)].ziva;
#+end_src

change the starting point in the sample (0.0 for beginning, 1.0 for end)

#+begin_src sclang
[~delia.start(0.5)].ziva;
#+end_src

slices the sample in a number of chunks (second argument), and plays
a sequence of them. The size of the sequence is given by the
first argument.
This example sequences 4 pieces chosen from a list of 8 chunks.

#+begin_src sclang
[~delia.chop(4, 8)].ziva;

#+end_src

MIDI
MIDI instruments can also be played, but MIDI needs to be initialized first.
Initialize the client

#+begin_src sclang
MIDIClient.init;
#+end_src

connect the first output of SC 'MIDIOut(0)' to your MIDI device in your User Iterface.
this is different for each operative system
then create a musician that plays that instrument.

#+begin_src sclang
~wendy = Pmidi(MIDIOut(0));
#+end_src

'MIDIOut(0)' syntax may be different for OSX and Windows -- this is just Linux
MIDI channel is optional, default is 0 -- in SC MIDI channels range 0-15

#+begin_src sclang
[ ~wendy.oct(4).deg([0,2,4].pseq) ].ziva;

#+end_src

DRUMS
drums can be just synths or samples, but there's a special class for the
free AVL plugin that can be downloaded at http://www.bandshed.net/avldrumkits/
//
create a drummer that sends MIDI

#+begin_src sclang
~bonzo = Pavldrums(MIDIOut(0));
#+end_src

with this, you can play drums with strings of characters, where
specific characters are mapped to certain MIDI notes corresponding
to specific drum kits in the AVL plugin.
spaces are rests

#+begin_src sclang
[ ~bonzo.drums("b h s h b h s o ").faster ].ziva;
#+end_src

to see the mappings

#+begin_src sclang
Ziva.drums;
#+end_src


*** SEQUENCING
// Parameters can be set to change automatically with PATTERNS.
// There is a HUGE amount of patterns in SuperCollider, but a lot can be
// done with very few. Here we'll present only some of them.

// .pseq(repeats:inf) is used to repeat a list of values for a number of
// times. If no 'repeats' are specified, it loops for ever.
[~lola.deg([0,2,4].pseq)].ziva;
// .prand(repeats:inf) picks a random value from the list on each event (hit)
[~lola.deg([0,1,2,3,4].prand)].ziva;
// patterns can be nested
[~lola.faster.deg([0,1,2, [7,8,9].pseq(2)].prand)].ziva;

// other interesting patterns are Place, Pshuf, Pbrown, Pwhite, Pstutter, ...
// See A-Practical-Guide/PG_02_Basic_Vocabulary in SCHelp.

// patterns can modulate any parameter
(
[
	~lola.faster.pizz.deg(Pbrown(0,7,1)).oct(6).cutoff(Pwhite(200,9000)).pan(Pwhite(-1.0)),
	~lola.faster.legato(Pwhite(0.1,1.2)).bj(4,7).cutoff(8000),
	~lola.oct([3,4].pseq),
].ziva;
)

* MODULATION
// Another way to modulate parameters is with LFOs (Low Frequency Oscillator).
// This example creates a sine wave oscillator and uses it to modulate the
// cutoff frequency of our \acid synth.
~sine1 = Ziva.lfo(1, wave:\sine, freq:0.6, min:200, max:8000  );
[~lola.legato.cutoff(~sine1)].ziva;
// you can create as many LFOs as you want, but the first parameter must be
// different for each LFO or it will be overwitten (can be a number or a symbol)
// other LFO wave shapes are: \sine, \saw, \pulse, \tri, \noise0, \noise1, \noise2

* EFFECTS
// Effects are applied to tracks, not sounds.
// There are 4 tracks available.
// Any number of effects can be applied to each track (including none).
// Order matters.
// To list the available effects
Ziva.fx; // see the post window

Ziva.boot; // this must be called -- it's of bug, will be fixed
// to setup effects for tracks
Ziva.track(0, \lowpass, \reverbL);
Ziva.track(1, \delay);
// then connect each sond to the desired track
(
[
	~lola.oct([3,4]).cutoff(9000) >> 0,
	~lola.pizz.slow >> 1,
].ziva;
)
Ziva.track(0); // remove the fx from track 0
* TODO Živa quick reference
* TODO Živa tips and tricks
- which will list all SynthDefs loaded on the server.  New synths can be loaded anytime as you would normally do in SuperCollider with:
#+begin_src sclang
SynthDef(...).add;
#+end_src
